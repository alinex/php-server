/** @page tests Automatic Tests

The goal of automatic testing is to isolate each part of the program and show
that the individual parts are correct. A unit test provides a strict, written
contract that the piece of code must satisfy. As a result, it affords several
benefits.

@section unitTests Unit Tests

This gives us the following advanteges:
- <b>Find problems early</b>\n
Unit tests find problems early in the development cycle.
If test-driven development (TDD), which is frequently used in both Extreme
Programming and Scrum, is used unit tests are created before the code itself
is written. When the tests pass, that code is considered complete.
- <b>Facilitates change</b>\n
Unit testing allows the programmer to refactor code at a later date, and make
sure the module still works correctly (e.g., in regression testing).
The procedure is to write test cases for all functions and methods so that
whenever a change causes a fault, it can be quickly identified and fixed.

@section inlineTesting Inline code testing

Additionally to the unit tests assertions are used to report internal code
problems in functions and methods which occur because of incorrect interface
usage with wrong data. This checks won't be run in productive code. For more
information see the Alinex\Util\AssertHandler for more information.

Only if the data comes from external sources use the Alinex\Validator classes
directly instead.

@section limitations Limitations

Testing cannot be expected to catch every error in the program: it is impossible
to evaluate every execution path in all but the most trivial programs.
The same is true for unit testing. Additionally, unit testing by definition only
tests the functionality of the units themselves.

@section conclusion Conclusion

In Alinex we aim a complete unit tested system as far as possible.

*/
